"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("@lwc/shared");
const errors_1 = require("@lwc/errors");
const html_1 = require("./html");
const attribute_1 = require("./attribute");
const expression_1 = require("./expression");
const t = __importStar(require("../shared/estree"));
const ir_1 = require("../shared/ir");
const types_1 = require("../shared/types");
const constants_1 = require("./constants");
function attributeExpressionReferencesForOfIndex(attribute, forOf) {
    const { value } = attribute;
    // if not an expression, it is not referencing iterator index
    if (!t.isMemberExpression(value)) {
        return false;
    }
    const { object, property } = value;
    if (!t.isIdentifier(object) || !t.isIdentifier(property)) {
        return false;
    }
    if (forOf.iterator.name !== object.name) {
        return false;
    }
    return property.name === 'index';
}
function attributeExpressionReferencesForEachIndex(attribute, forEach) {
    const { index } = forEach;
    const { value } = attribute;
    // No index defined on foreach
    if (!index || !t.isIdentifier(index) || !t.isIdentifier(value)) {
        return false;
    }
    return index.name === value.name;
}
function parse(source, state) {
    const warnings = [];
    const seenIds = new Set();
    const { fragment, errors: parsingErrors } = html_1.parseHTML(source);
    if (parsingErrors.length) {
        return { warnings: parsingErrors };
    }
    const templateRoot = getTemplateRoot(fragment);
    if (!templateRoot) {
        return { warnings };
    }
    const root = parseElement(templateRoot);
    function parseElement(elementNode, parent) {
        const element = ir_1.createElement(elementNode, parent);
        applyForEach(element);
        applyIterator(element);
        applyIf(element);
        applyHandlers(element);
        applyComponent(element);
        applySlot(element);
        applyKey(element);
        applyLwcDirectives(element);
        applyAttributes(element);
        validateElement(element);
        validateAttributes(element);
        validateProperties(element);
        parseChildren(element);
        validateChildren(element);
        return element;
    }
    function parseChildren(parent) {
        var _a;
        const { __original } = parent;
        const parsedChildren = [];
        const children = html_1.treeAdapter.getChildNodes((_a = html_1.treeAdapter.getTemplateContent(__original)) !== null && _a !== void 0 ? _a : __original);
        for (const child of children) {
            if (html_1.treeAdapter.isElementNode(child)) {
                const elmNode = parseElement(child, parent);
                parsedChildren.push(elmNode);
            }
            else if (html_1.treeAdapter.isTextNode(child)) {
                const textNodes = parseText(child, parent);
                parsedChildren.push(...textNodes);
            }
            else if (html_1.treeAdapter.isCommentNode(child)) {
                const commentNode = parseComment(child, parent);
                parsedChildren.push(commentNode);
            }
        }
        parent.children = parsedChildren;
    }
    function parseText(node, parent) {
        const parsedTextNodes = [];
        // Extract the raw source to avoid HTML entity decoding done by parse5
        const location = node.__location;
        const rawText = html_1.cleanTextNode(source.slice(location.startOffset, location.endOffset));
        if (!rawText.trim().length) {
            return parsedTextNodes;
        }
        // Split the text node content arround expression and create node for each
        const tokenizedContent = rawText.split(constants_1.EXPRESSION_RE);
        for (const token of tokenizedContent) {
            // Don't create nodes for emtpy strings
            if (!token.length) {
                continue;
            }
            let value;
            if (expression_1.isExpression(token)) {
                try {
                    value = expression_1.parseExpression(token, state);
                }
                catch (error) {
                    addDiagnostic(errors_1.normalizeToDiagnostic(errors_1.ParserDiagnostics.TEMPLATE_EXPRESSION_PARSING_ERROR, error, {
                        location: normalizeLocation(location),
                    }));
                    return parsedTextNodes;
                }
            }
            else {
                value = html_1.decodeTextContent(token);
            }
            parsedTextNodes.push(ir_1.createText(node, parent, value));
        }
        return parsedTextNodes;
    }
    function parseComment(node, parent) {
        const value = html_1.decodeTextContent(node.data);
        return ir_1.createComment(node, parent, value);
    }
    function getTemplateRoot(documentFragment) {
        // Filter all the empty text nodes
        const validRoots = documentFragment.childNodes.filter((child) => html_1.treeAdapter.isElementNode(child) ||
            (html_1.treeAdapter.isTextNode(child) && child.value.trim().length));
        if (validRoots.length > 1) {
            warnOnElement(errors_1.ParserDiagnostics.MULTIPLE_ROOTS_FOUND, documentFragment.childNodes[1]);
        }
        const [root] = validRoots;
        if (!root || !html_1.treeAdapter.isElementNode(root)) {
            warnAt(errors_1.ParserDiagnostics.MISSING_ROOT_TEMPLATE_TAG);
        }
        else {
            return root;
        }
    }
    function applyHandlers(element) {
        let eventHandlerAttribute = getTemplateAttribute(element, constants_1.EVENT_HANDLER_RE);
        while (eventHandlerAttribute) {
            attribute_1.removeAttribute(element, eventHandlerAttribute.name);
            if (eventHandlerAttribute.type !== types_1.IRAttributeType.Expression) {
                return warnAt(errors_1.ParserDiagnostics.EVENT_HANDLER_SHOULD_BE_EXPRESSION, [], eventHandlerAttribute.location);
            }
            let eventName = eventHandlerAttribute.name;
            if (!eventName.match(constants_1.EVENT_HANDLER_NAME_RE)) {
                return warnAt(errors_1.ParserDiagnostics.INVALID_EVENT_NAME, [eventName], eventHandlerAttribute.location);
            }
            // Strip the `on` prefix from the event handler name
            eventName = eventHandlerAttribute.name.slice(2);
            const on = element.on || (element.on = {});
            on[eventName] = eventHandlerAttribute.value;
            eventHandlerAttribute = getTemplateAttribute(element, constants_1.EVENT_HANDLER_RE);
        }
    }
    function applyIf(element) {
        const ifAttribute = getTemplateAttribute(element, constants_1.IF_RE);
        if (ifAttribute) {
            attribute_1.removeAttribute(element, constants_1.IF_RE);
            if (ifAttribute.type !== types_1.IRAttributeType.Expression) {
                return warnAt(errors_1.ParserDiagnostics.IF_DIRECTIVE_SHOULD_BE_EXPRESSION, [], ifAttribute.location);
            }
            const [, modifier] = ifAttribute.name.split(':');
            if (!constants_1.VALID_IF_MODIFIER.has(modifier)) {
                return warnAt(errors_1.ParserDiagnostics.UNEXPECTED_IF_MODIFIER, [modifier], ifAttribute.location);
            }
            element.if = ifAttribute.value;
            element.ifModifier = modifier;
        }
    }
    function applyLwcDirectives(element) {
        const lwcAttribute = getTemplateAttribute(element, constants_1.LWC_RE);
        if (!lwcAttribute) {
            return;
        }
        if (!constants_1.LWC_DIRECTIVE_SET.has(lwcAttribute.name) &&
            !constants_1.ROOT_TEMPLATE_DIRECTIVES_SET.has(lwcAttribute.name)) {
            // unknown lwc directive
            return warnOnElement(errors_1.ParserDiagnostics.UNKNOWN_LWC_DIRECTIVE, element.__original, [
                lwcAttribute.name,
                `<${element.tag}>`,
            ]);
        }
        const lwcOpts = {};
        applyLwcDynamicDirective(element, lwcOpts);
        applyLwcDomDirective(element, lwcOpts);
        applyLwcRenderModeDirective(element, lwcOpts);
        applyLwcPreserveCommentsDirective(element, lwcOpts);
        element.lwc = lwcOpts;
    }
    function applyLwcRenderModeDirective(element, lwcOpts) {
        const lwcRenderModeAttribute = getTemplateAttribute(element, constants_1.ROOT_TEMPLATE_DIRECTIVES.RENDER_MODE);
        if (!lwcRenderModeAttribute) {
            return;
        }
        if (lwcRenderModeAttribute.type !== types_1.IRAttributeType.String ||
            (lwcRenderModeAttribute.value !== 'shadow' && lwcRenderModeAttribute.value !== 'light')) {
            return warnOnElement(errors_1.ParserDiagnostics.LWC_RENDER_MODE_INVALID_VALUE, element.__original);
        }
        if (element.parent) {
            return warnOnElement(errors_1.ParserDiagnostics.UNKNOWN_LWC_DIRECTIVE, element.__original, [
                constants_1.ROOT_TEMPLATE_DIRECTIVES.RENDER_MODE,
                `<${element.tag}>`,
            ]);
        }
        lwcOpts.renderMode = lwcRenderModeAttribute.value;
    }
    function applyLwcPreserveCommentsDirective(element, lwcOpts) {
        const lwcPreserveCommentAttribute = getTemplateAttribute(element, constants_1.ROOT_TEMPLATE_DIRECTIVES.PRESERVE_COMMENTS);
        if (!lwcPreserveCommentAttribute) {
            return;
        }
        if (element.parent || lwcPreserveCommentAttribute.type !== types_1.IRAttributeType.Boolean) {
            return warnOnElement(errors_1.ParserDiagnostics.UNKNOWN_LWC_DIRECTIVE, element.__original, [
                constants_1.ROOT_TEMPLATE_DIRECTIVES.RENDER_MODE,
                `<${element.tag}>`,
            ]);
        }
        lwcOpts.preserveComments = lwcPreserveCommentAttribute;
    }
    function applyLwcDynamicDirective(element, lwcOpts) {
        const lwcDynamicAttribute = getTemplateAttribute(element, constants_1.LWC_DIRECTIVES.DYNAMIC);
        if (!lwcDynamicAttribute) {
            return;
        }
        if (!state.config.experimentalDynamicDirective) {
            return warnOnElement(errors_1.ParserDiagnostics.INVALID_OPTS_LWC_DYNAMIC, element.__original, [
                `<${element.tag}>`,
            ]);
        }
        attribute_1.removeAttribute(element, constants_1.LWC_DIRECTIVES.DYNAMIC);
        if (!ir_1.isCustomElement(element)) {
            return warnOnElement(errors_1.ParserDiagnostics.INVALID_LWC_DYNAMIC_ON_NATIVE_ELEMENT, element.__original, [`<${element.tag}>`]);
        }
        if (lwcDynamicAttribute.type !== types_1.IRAttributeType.Expression) {
            return warnOnElement(errors_1.ParserDiagnostics.INVALID_LWC_DYNAMIC_LITERAL_PROP, element.__original, [`<${element.tag}>`]);
        }
        lwcOpts.dynamic = lwcDynamicAttribute.value;
    }
    function applyLwcDomDirective(element, lwcOpts) {
        const lwcDomAttribute = getTemplateAttribute(element, constants_1.LWC_DIRECTIVES.DOM);
        if (!lwcDomAttribute) {
            return;
        }
        attribute_1.removeAttribute(element, constants_1.LWC_DIRECTIVES.DOM);
        if (getRenderMode(element) === types_1.LWCDirectiveRenderMode.light) {
            return warnOnElement(errors_1.ParserDiagnostics.LWC_DOM_INVALID_IN_LIGHT_DOM, element.__original, [`<${element.tag}>`]);
        }
        if (ir_1.isCustomElement(element)) {
            return warnOnElement(errors_1.ParserDiagnostics.LWC_DOM_INVALID_CUSTOM_ELEMENT, element.__original, [`<${element.tag}>`]);
        }
        if (element.tag === 'slot') {
            return warnOnElement(errors_1.ParserDiagnostics.LWC_DOM_INVALID_SLOT_ELEMENT, element.__original);
        }
        if (lwcDomAttribute.type !== types_1.IRAttributeType.String ||
            shared_1.hasOwnProperty.call(types_1.LWCDirectiveDomMode, lwcDomAttribute.value) === false) {
            const possibleValues = Object.keys(types_1.LWCDirectiveDomMode)
                .map((value) => `"${value}"`)
                .join(', or ');
            return warnOnElement(errors_1.ParserDiagnostics.LWC_DOM_INVALID_VALUE, element.__original, [
                possibleValues,
            ]);
        }
        lwcOpts.dom = lwcDomAttribute.value;
    }
    function applyForEach(element) {
        const forEachAttribute = getTemplateAttribute(element, 'for:each');
        const forItemAttribute = getTemplateAttribute(element, 'for:item');
        const forIndex = getTemplateAttribute(element, 'for:index');
        if (forEachAttribute && forItemAttribute) {
            // If both directives are defined
            attribute_1.removeAttribute(element, forEachAttribute.name);
            attribute_1.removeAttribute(element, forItemAttribute.name);
            if (forEachAttribute.type !== types_1.IRAttributeType.Expression) {
                return warnAt(errors_1.ParserDiagnostics.FOR_EACH_DIRECTIVE_SHOULD_BE_EXPRESSION, [], forEachAttribute.location);
            }
            else if (forItemAttribute.type !== types_1.IRAttributeType.String) {
                return warnAt(errors_1.ParserDiagnostics.FOR_ITEM_DIRECTIVE_SHOULD_BE_STRING, [], forItemAttribute.location);
            }
            let item;
            try {
                item = expression_1.parseIdentifier(forItemAttribute.value);
            }
            catch (error) {
                return addDiagnostic(errors_1.normalizeToDiagnostic(errors_1.ParserDiagnostics.IDENTIFIER_PARSING_ERROR, error, {
                    location: normalizeLocation(forItemAttribute.location),
                }));
            }
            let index;
            if (forIndex) {
                attribute_1.removeAttribute(element, forIndex.name);
                if (forIndex.type !== types_1.IRAttributeType.String) {
                    return warnAt(errors_1.ParserDiagnostics.FOR_INDEX_DIRECTIVE_SHOULD_BE_STRING, [], forIndex.location);
                }
                try {
                    index = expression_1.parseIdentifier(forIndex.value);
                }
                catch (error) {
                    return addDiagnostic(errors_1.normalizeToDiagnostic(errors_1.ParserDiagnostics.IDENTIFIER_PARSING_ERROR, error, {
                        location: normalizeLocation(forIndex.location),
                    }));
                }
            }
            element.forEach = {
                expression: forEachAttribute.value,
                item,
                index,
            };
        }
        else if (forEachAttribute || forItemAttribute) {
            // If only one directive is defined
            return warnOnElement(errors_1.ParserDiagnostics.FOR_EACH_AND_FOR_ITEM_DIRECTIVES_SHOULD_BE_TOGETHER, element.__original);
        }
    }
    function applyIterator(element) {
        const iteratorExpression = getTemplateAttribute(element, constants_1.ITERATOR_RE);
        if (!iteratorExpression) {
            return;
        }
        if (element.forEach) {
            return warnOnElement(errors_1.ParserDiagnostics.INVALID_FOR_EACH_WITH_ITERATOR, element.__original, [iteratorExpression.name]);
        }
        attribute_1.removeAttribute(element, iteratorExpression.name);
        const iteratorAttributeName = iteratorExpression.name;
        const [, iteratorName] = iteratorAttributeName.split(':');
        if (iteratorExpression.type !== types_1.IRAttributeType.Expression) {
            return warnAt(errors_1.ParserDiagnostics.DIRECTIVE_SHOULD_BE_EXPRESSION, [iteratorExpression.name], iteratorExpression.location);
        }
        let iterator;
        try {
            iterator = expression_1.parseIdentifier(iteratorName);
        }
        catch (error) {
            return addDiagnostic(errors_1.normalizeToDiagnostic(errors_1.ParserDiagnostics.IDENTIFIER_PARSING_ERROR, error, {
                location: normalizeLocation(iteratorExpression.location),
            }));
        }
        element.forOf = {
            expression: iteratorExpression.value,
            iterator,
        };
    }
    function applyKey(element) {
        const keyAttribute = getTemplateAttribute(element, 'key');
        if (keyAttribute) {
            if (keyAttribute.type !== types_1.IRAttributeType.Expression) {
                return warnAt(errors_1.ParserDiagnostics.KEY_ATTRIBUTE_SHOULD_BE_EXPRESSION, [], keyAttribute.location);
            }
            const forOfParent = expression_1.getForOfParent(element);
            const forEachParent = expression_1.getForEachParent(element);
            if (forOfParent) {
                if (attributeExpressionReferencesForOfIndex(keyAttribute, forOfParent.forOf)) {
                    return warnAt(errors_1.ParserDiagnostics.KEY_SHOULDNT_REFERENCE_ITERATOR_INDEX, [element.tag], keyAttribute.location);
                }
            }
            else if (forEachParent) {
                if (attributeExpressionReferencesForEachIndex(keyAttribute, forEachParent.forEach)) {
                    const name = 'name' in keyAttribute.value && keyAttribute.value.name;
                    return warnAt(errors_1.ParserDiagnostics.KEY_SHOULDNT_REFERENCE_FOR_EACH_INDEX, [element.tag, name], keyAttribute.location);
                }
            }
            attribute_1.removeAttribute(element, 'key');
            element.forKey = keyAttribute.value;
        }
        else if (expression_1.isIteratorElement(element) && element.tag !== 'template') {
            return warnAt(errors_1.ParserDiagnostics.MISSING_KEY_IN_ITERATOR, [element.tag], element.__original.__location);
        }
    }
    function applyComponent(element) {
        const { tag } = element;
        // Check if the element tag is a valid custom element name and is not part of known standard
        // element name containing a dash.
        if (!tag.includes('-') || constants_1.DASHED_TAGNAME_ELEMENT_SET.has(tag)) {
            return;
        }
        element.component = tag;
    }
    function applySlot(element) {
        const { tag, attrsList } = element;
        // Early exit if the element is not a slot
        if (tag !== 'slot') {
            return;
        }
        if (element.forEach || element.forOf || element.if) {
            return warnOnElement(errors_1.ParserDiagnostics.SLOT_TAG_CANNOT_HAVE_DIRECTIVES, element.__original);
        }
        // Can't handle slots in applySlot because it would be too late for class and style attrs
        if (getRenderMode(element) === types_1.LWCDirectiveRenderMode.light) {
            const invalidAttrs = attrsList
                .filter(({ name }) => name !== 'name')
                .map(({ name }) => name);
            if (invalidAttrs.length > 0) {
                return warnOnElement(errors_1.ParserDiagnostics.LWC_LIGHT_SLOT_INVALID_ATTRIBUTES, element.__original, [invalidAttrs.join(',')]);
            }
        }
        // Default slot have empty string name
        let name = '';
        const nameAttribute = getTemplateAttribute(element, 'name');
        if (nameAttribute) {
            if (nameAttribute.type === types_1.IRAttributeType.Expression) {
                return warnAt(errors_1.ParserDiagnostics.NAME_ON_SLOT_CANNOT_BE_EXPRESSION, [], nameAttribute.location);
            }
            else if (nameAttribute.type === types_1.IRAttributeType.String) {
                name = nameAttribute.value;
            }
        }
        element.slotName = name;
    }
    function isInIteration(element) {
        if (element.tag === 'template') {
            if (element.forEach || element.forOf) {
                return true;
            }
        }
        if (element.parent) {
            return isInIteration(element.parent);
        }
        return false;
    }
    function applyAttributes(element) {
        const { tag, attrsList } = element;
        attrsList.forEach((rawAttr) => {
            const attr = getTemplateAttribute(element, attribute_1.attributeName(rawAttr));
            if (!attr) {
                return;
            }
            const { name, location } = attr;
            if (!attribute_1.isValidHTMLAttribute(element.tag, name)) {
                warnAt(errors_1.ParserDiagnostics.INVALID_HTML_ATTRIBUTE, [name, tag], location);
            }
            if (name.match(/[^a-z0-9]$/)) {
                warnAt(errors_1.ParserDiagnostics.ATTRIBUTE_NAME_MUST_END_WITH_ALPHA_NUMERIC_CHARACTER, [
                    name,
                    tag,
                ]);
                return;
            }
            if (!/^-*[a-z]/.test(name)) {
                warnAt(errors_1.ParserDiagnostics.ATTRIBUTE_NAME_MUST_START_WITH_ALPHABETIC_OR_HYPHEN_CHARACTER, [name, tag]);
                return;
            }
            // disallow attr name which combines underscore character with special character.
            // We normalize camel-cased names with underscores caMel -> ca-mel; thus sanitization.
            if (name.match(/_[^a-z0-9]|[^a-z0-9]_/)) {
                warnAt(errors_1.ParserDiagnostics.ATTRIBUTE_NAME_CANNOT_COMBINE_UNDERSCORE_WITH_SPECIAL_CHARS, [name, tag]);
                return;
            }
            if (attr.type === types_1.IRAttributeType.String) {
                if (name === 'id') {
                    const { value } = attr;
                    if (/\s+/.test(value)) {
                        warnAt(errors_1.ParserDiagnostics.INVALID_ID_ATTRIBUTE, [value], location);
                    }
                    if (isInIteration(element)) {
                        warnAt(errors_1.ParserDiagnostics.INVALID_STATIC_ID_IN_ITERATION, [value], location);
                    }
                    if (seenIds.has(value)) {
                        warnAt(errors_1.ParserDiagnostics.DUPLICATE_ID_FOUND, [value], location);
                    }
                    else {
                        seenIds.add(value);
                    }
                }
            }
            // Prevent usage of the slot attribute with expression.
            if (name === 'slot' && attr.type === types_1.IRAttributeType.Expression) {
                return warnAt(errors_1.ParserDiagnostics.SLOT_ATTRIBUTE_CANNOT_BE_EXPRESSION, [], location);
            }
            // the if branch handles
            // 1. All attributes for standard elements except 1 case are handled as attributes
            // 2. For custom elements, only key, slot and data are handled as attributes, rest as properties
            if (attribute_1.isAttribute(element, name)) {
                const attrs = element.attrs || (element.attrs = {});
                attrs[name] = attr;
            }
            else {
                const props = element.props || (element.props = {});
                props[attribute_1.attributeToPropertyName(name)] = attr;
                attribute_1.removeAttribute(element, name);
            }
        });
    }
    function validateElement(element) {
        const { tag, parent, __original: node } = element;
        const isRoot = !parent;
        if (isRoot) {
            if (tag !== 'template') {
                return warnOnElement(errors_1.ParserDiagnostics.ROOT_TAG_SHOULD_BE_TEMPLATE, node, [tag]);
            }
            const rootHasUnknownAttributes = node.attrs.some(({ name }) => !constants_1.ROOT_TEMPLATE_DIRECTIVES_SET.has(name));
            if (rootHasUnknownAttributes) {
                return warnOnElement(errors_1.ParserDiagnostics.ROOT_TEMPLATE_HAS_UNKNOWN_ATTRIBUTES, node);
            }
        }
        // Check if a non-void element has a matching closing tag.
        //
        // With parse5 automatically recovering from invalid HTML, some AST nodes might not have
        // location information. For example when a <table> element has a <tr> child element, parse5
        // creates a <tbody> element in the middle without location information. In this case, we
        // can safely skip the closing tag validation.
        if (node.__location) {
            const { startTag, endTag } = node.__location;
            const isVoidElement = constants_1.VOID_ELEMENT_SET.has(element.tag);
            const hasClosingTag = Boolean(endTag);
            if (!isVoidElement && !hasClosingTag) {
                addDiagnostic(errors_1.generateCompilerDiagnostic(errors_1.ParserDiagnostics.NO_MATCHING_CLOSING_TAGS, {
                    messageArgs: [element.tag],
                    origin: {
                        location: {
                            line: startTag.startLine || startTag.line,
                            column: startTag.startCol || startTag.col,
                            start: startTag.startOffset,
                            length: startTag.endOffset - startTag.startOffset,
                        },
                    },
                }));
            }
        }
        if (tag === 'style' && node.namespaceURI === constants_1.HTML_NAMESPACE_URI) {
            warnOnElement(errors_1.ParserDiagnostics.STYLE_TAG_NOT_ALLOWED_IN_TEMPLATE, node);
        }
        else if (tag === 'template') {
            // We check if the template element has some modifier applied to it. Directly checking if one of the
            // IRElement property is impossible. For example when an error occurs during the parsing of the if
            // expression, the `element.if` property remains undefined. It would results in 2 warnings instead of 1:
            //      - Invalid if expression
            //      - Unexpected template element
            //
            // Checking if the original HTMLElement has some attributes applied is a good enough for now.
            const hasAttributes = node.attrs.length !== 0;
            if (!isRoot && !hasAttributes) {
                warnOnElement(errors_1.ParserDiagnostics.NO_DIRECTIVE_FOUND_ON_TEMPLATE, node);
            }
        }
        else {
            const namespace = node.namespaceURI;
            const isNotAllowedHtmlTag = constants_1.DISALLOWED_HTML_TAGS.has(tag);
            if (namespace === constants_1.HTML_NAMESPACE_URI && isNotAllowedHtmlTag) {
                return warnOnElement(errors_1.ParserDiagnostics.FORBIDDEN_TAG_ON_TEMPLATE, node, [tag]);
            }
            const isNotAllowedSvgTag = !constants_1.SUPPORTED_SVG_TAGS.has(tag);
            if (namespace === constants_1.SVG_NAMESPACE_URI && isNotAllowedSvgTag) {
                return warnOnElement(errors_1.ParserDiagnostics.FORBIDDEN_SVG_NAMESPACE_IN_TEMPLATE, node, [
                    tag,
                ]);
            }
            const isNotAllowedMathMlTag = constants_1.DISALLOWED_MATHML_TAGS.has(tag);
            if (namespace === constants_1.MATHML_NAMESPACE_URI && isNotAllowedMathMlTag) {
                return warnOnElement(errors_1.ParserDiagnostics.FORBIDDEN_MATHML_NAMESPACE_IN_TEMPLATE, node, [tag]);
            }
            const isKnownTag = ir_1.isCustomElement(element) ||
                constants_1.KNOWN_HTML_ELEMENTS.has(tag) ||
                constants_1.SUPPORTED_SVG_TAGS.has(tag) ||
                constants_1.DASHED_TAGNAME_ELEMENT_SET.has(tag);
            if (!isKnownTag) {
                return warnOnElement(errors_1.ParserDiagnostics.UNKNOWN_HTML_TAG_IN_TEMPLATE, node, [tag]);
            }
        }
    }
    function validateChildren(element) {
        var _a;
        const effectiveChildren = getPreserveComments(element)
            ? element.children
            : element.children.filter((child) => child.type !== 'comment');
        if (((_a = element.lwc) === null || _a === void 0 ? void 0 : _a.dom) && effectiveChildren.length > 0) {
            return warnOnElement(errors_1.ParserDiagnostics.LWC_DOM_INVALID_CONTENTS, element.__original);
        }
    }
    function validateAttributes(element) {
        const { tag, attrsList, __original: node } = element;
        attrsList.forEach((attr) => {
            const attrName = attr.name;
            if (attribute_1.isProhibitedIsAttribute(attrName)) {
                warnOnElement(errors_1.ParserDiagnostics.IS_ATTRIBUTE_NOT_SUPPORTED, node, [attrName, tag]);
            }
            if (attribute_1.isTabIndexAttribute(attrName)) {
                if (!expression_1.isExpression(attr.value) && !attribute_1.isValidTabIndexAttributeValue(attr.value)) {
                    warnOnElement(errors_1.ParserDiagnostics.INVALID_TABINDEX_ATTRIBUTE, node);
                }
            }
            // TODO [#1136]: once the template compiler emits the element namespace information to the engine we should
            // restrict the validation of the "srcdoc" attribute on the "iframe" element only if this element is
            // part of the HTML namespace.
            if (tag === 'iframe' && attrName === 'srcdoc') {
                warnOnElement(errors_1.ParserDiagnostics.FORBIDDEN_IFRAME_SRCDOC_ATTRIBUTE, node);
            }
        });
    }
    function validateProperties(element) {
        const { tag, props, __original: node } = element;
        if (props !== undefined) {
            for (const propName in props) {
                const { name: attrName, type, value } = props[propName];
                if (attribute_1.isProhibitedIsAttribute(attrName)) {
                    warnOnElement(errors_1.ParserDiagnostics.IS_ATTRIBUTE_NOT_SUPPORTED, node, [
                        attrName,
                        tag,
                    ]);
                }
                if (attribute_1.isTabIndexAttribute(attrName)) {
                    if (type !== types_1.IRAttributeType.Expression &&
                        !attribute_1.isValidTabIndexAttributeValue(value)) {
                        warnOnElement(errors_1.ParserDiagnostics.INVALID_TABINDEX_ATTRIBUTE, node);
                    }
                }
            }
        }
    }
    function getTemplateAttribute(el, pattern) {
        const node = el.__original;
        const nodeLocation = node.__location;
        const matching = attribute_1.getAttribute(el, pattern);
        if (!matching) {
            return;
        }
        const name = matching.prefix ? `${matching.prefix}:${matching.name}` : matching.name;
        // Convert attribute name to lowercase because the location map keys follow the algorithm defined in the spec
        // https://wicg.github.io/controls-list/html-output/multipage/syntax.html#attribute-name-state
        const location = nodeLocation.attrs[name.toLowerCase()];
        const rawAttribute = html_1.getSource(source, location);
        // parse5 automatically converts the casing from camelcase to all lowercase. If the attribute name
        // is not the same before and after the parsing, then the attribute name contains capital letters
        if (!rawAttribute.startsWith(name)) {
            warnAt(errors_1.ParserDiagnostics.INVALID_ATTRIBUTE_CASE, [rawAttribute, html_1.treeAdapter.getTagName(node)], location);
            return;
        }
        try {
            const isBooleanAttribute = !rawAttribute.includes('=');
            const { value, escapedExpression } = attribute_1.normalizeAttributeValue(matching, rawAttribute, el.tag);
            if (expression_1.isExpression(value) && !escapedExpression) {
                return {
                    name,
                    location,
                    type: types_1.IRAttributeType.Expression,
                    value: expression_1.parseExpression(value, state),
                };
            }
            else if (isBooleanAttribute) {
                return {
                    name,
                    location,
                    type: types_1.IRAttributeType.Boolean,
                    value: true,
                };
            }
            else {
                return {
                    name,
                    location,
                    type: types_1.IRAttributeType.String,
                    value,
                };
            }
        }
        catch (error) {
            // Removes the attribute, if impossible to parse it value.
            attribute_1.removeAttribute(el, name);
            addDiagnostic(errors_1.normalizeToDiagnostic(errors_1.ParserDiagnostics.GENERIC_PARSING_ERROR, error, {
                location: normalizeLocation(location),
            }));
        }
    }
    function getRoot(element) {
        return element.parent ? getRoot(element.parent) : element;
    }
    function getRenderMode(element) {
        var _a, _b;
        return (_b = (_a = getRoot(element).lwc) === null || _a === void 0 ? void 0 : _a.renderMode) !== null && _b !== void 0 ? _b : types_1.LWCDirectiveRenderMode.shadow;
    }
    function getPreserveComments(element) {
        var _a, _b, _c;
        return (_c = (_b = (_a = getRoot(element).lwc) === null || _a === void 0 ? void 0 : _a.preserveComments) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : state.config.preserveHtmlComments;
    }
    function warnOnElement(errorInfo, node, messageArgs) {
        const getLocation = (toLocate) => {
            if (!toLocate) {
                return { line: 0, column: 0, start: 0, length: 0 };
            }
            const location = toLocate.__location;
            if (!location) {
                return getLocation(html_1.treeAdapter.getParentNode(toLocate));
            }
            else {
                return {
                    line: location.line || location.startLine,
                    column: location.col || location.startCol,
                    start: location.startOffset,
                    length: location.endOffset - location.startOffset,
                };
            }
        };
        addDiagnostic(errors_1.generateCompilerDiagnostic(errorInfo, {
            messageArgs,
            origin: {
                location: getLocation(node),
            },
        }));
    }
    function warnAt(errorInfo, messageArgs, location) {
        addDiagnostic(errors_1.generateCompilerDiagnostic(errorInfo, {
            messageArgs,
            origin: {
                location: normalizeLocation(location),
            },
        }));
    }
    // TODO [#1286]: Update parse5-with-error to match version used for jsdom (interface for ElementLocation changed)
    function normalizeLocation(location) {
        let line = 0;
        let column = 0;
        let start = 0;
        let length = 0;
        if (location) {
            const { startOffset, endOffset } = location;
            line = location.line || location.startLine;
            column = location.col || location.startCol;
            start = startOffset;
            length = endOffset - startOffset;
        }
        return { line, column, start, length };
    }
    function addDiagnostic(diagnostic) {
        warnings.push(diagnostic);
    }
    return { root, warnings };
}
exports.default = parse;
//# sourceMappingURL=index.js.map